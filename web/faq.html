<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<title>DHCP4Java FAQ</title>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
<META content="Stephan Hadinger" name="Author">
</head>

<body>
<h1>DHCP4Java FAQ</h1>
<h4>What is DHCP?</h4>
<p><em>[Extract from RFC 2131]</em><br>
  The Dynamic Host Configuration Protocol (DHCP) provides configuration parameters 
  to Internet hosts. DHCP consists of two components: a protocol for delivering 
  host-specific configuration parameters from a DHCP server to a host and a mechanism 
  for allocation of network addresses to hosts.</p>
<h4>What is a DHCP static/dynamic/algorithmic server?</h4>
<p>There are three basic ways to allocate IP addresses to clients: static (pre-configured 
  client by client), dynamic (allocated from address pools), algorithmic (calculated 
  from data in the request - often taken from option 82).</p>
<p><em>Static address allocation</em> is the simplest server to implement. It 
  requires that every client is pre-provisioned in the server. Each client is 
  always given the same address (hopefully) different from one client to another. 
  However this allocation scheme is not very flexible and generates high administrative 
  work to network administrators. It is still used for equipment needing fixed 
  IP addresses such as printers...</p>
<p><em>Dynamic address allocation</em> allows automatic address allocation generally 
  on a first-connected first-served scheme. Leases are limited in time to allow 
  address reuse if a client is permanently disconnected. This scheme requires 
  persistence on the server side which raises some availability issues. Such servers 
  should also be aware of denial of service caused by the exhaustion of all available 
  addresses from a bogus/malicious client.</p>
<p><em>Algorithmic address allocation</em> is a mix of the two previous schemes. 
  It can be seen as an &quot;automatic static server&quot; in which addresses 
  are not manually preallocated, but calculated on the fly with data taken from 
  the request. This is generally used by ISPs (cable or DSL) to assign a fixed 
  IP address to each physical line (cable or phone) allocated in sequence. This 
  is done by analysing the option 82 added by the DHCP relay which marks the id 
  of the physical line used. Simple calculation can be done to assign an IP address 
  based on the subnet and line-id information. This scheme is quite easy to implement 
  but has two drawbacks: it allows only 1 IP address per physical line, and it 
  needs pre-allocation of all possible IP addresses even if there is no connected 
  client. For this later reason, it is often limited to private non-routable IP 
  addresses.</p>
<p>DHCP4Java will first support <em>static</em> and <em>algorithmic</em> allocation. 
  Fully <em>dynamic</em> is for future plans.</p>
<p><strong>Why using Java for a DHCP Server</strong></p>
<p>Traditional DHCP Server implementations are built using C or C++. It appeared 
  quickly that such servers could be developed as well using higher productivity 
  languages such as PERL or Java.</p>
<p>Java offers unique opportunities to server development such as: easy multi-threading/multi-CPU/mutli-core 
  support, wide variety of connectivity APIs to databases through JDBC, wide community 
  of developers...</p>
<h4>Are there limitations introduced by Java</h4>
<p>Very few.</p>
<p>The UdpDatagram API does not allow to send datagrams to 255.255.255.255 IP 
  address (broadcast) using Ethernet unicast to a specific MAC address. This means 
  that DHCPOFFER are always broadcast on the network, as if the &quot;Broadcast 
  bit&quot; in client requests is always set. This has no impact on client, it 
  only generates little additionnal traffic on the link, which is totally negligible 
  on modern networks.</p>
<p>It is not possible to develop a DHCP Client in pure Java, due to a lack of 
  API to read the MAC address of the network link. You can still develop a test 
  Client or use system specific command/API.</p>
<h4>Does Java offer enough performance compared to C</h4>
<p>Yes. Comparative tests are planned, but Java performance is largely enough 
  even for high volume DHCP servers, see right below.</p>
<h4>How fast is DHCP4Java?</h4>
<p>The API has been designed to be fast enough to support very large scale DHCP 
  servers for millions of customers.</p>
<p>Formal performance tests are planned. However, preliminary tests show that 
  the API is able to handle more than 10.000 req/s on a simple Laptop (Pentium-M 
  1.5GHz) with 512MB memory.</p>
<p>My original API was implemented in PERL, but I decided to switch to Java to 
  broaden the potential developers audience. Porting the API from PERL to Java 
  showed a ~10x performance boost with additionnal support for multi-threading.</p>
<h4>Can I use DHCP4Java to implement a BOOTP server?</h4>
<p>Yes. DHCP4Java fully support BOOTP.</p>
<p>However my first goal is to develop a DHCP server. BOOTP code is largelly untested. 
  Use it at your own risk. Feedback and bug reports would be appreciated.</p>
<h4>Which RFCs are supported by DHCP4Java</h4>
<p>Our design objectives are to be totally conformant to RFC regarding BOOTP/DHCP. 
  Any non-conformant feature will be clearly documented and argumented. This may 
  include special work-arounds for client bugs or future DHCP feautures not totally 
  normalized yet.</p>
<p>This includes the following RFC:</p>
<p> <a href="http://www.ietf.org/rfc/rfc1534.txt">RFC 1534</a>: Interoperation 
  Between DHCP and BOOTP<br>
  <a href="http://www.ietf.org/rfc/rfc2131.txt">RFC 2131</a>: Dynamic Host Configuration 
  Protocol, Obsoletes RFC 1541<br>
  <a href="http://www.ietf.org/rfc/rfc2132.txt">RFC 2132</a>: DHCP Options and 
  BOOTP Vendor Extensions<br>
  <a href="http://www.ietf.org/rfc/rfc2241.txt">RFC 2241</a>: DHCP Options for 
  Novell Directory Services<br>
  <a href="http://www.ietf.org/rfc/rfc2242.txt">RFC 2242</a>: NetWare/IP Domain 
  Name and Information<br>
  <a href="http://www.ietf.org/rfc/rfc2855.txt">RFC 2855</a>: DHCP for IEEE 1394<br>
  <a href="http://www.ietf.org/rfc/rfc2937.txt">RFC 2937</a>: The Name Service 
  Search Option for DHCP<br>
  <a href="http://www.ietf.org/rfc/rfc3004.txt">RFC 3004</a>: The User Class Option 
  for DHCP<br>
  <a href="http://www.ietf.org/rfc/rfc3011.txt">RFC 3011</a>: The IPv4 Subnet 
  Selection Option for DHCP<br>
  <a href="http://www.ietf.org/rfc/rfc3046.txt">RFC 3046</a>: DHCP Relay Agent 
  Information Option<br>
  <a href="http://www.ietf.org/rfc/rfc3396.txt">RFC 3396</a>: Encoding Long Options 
  in the Dynamic Host Configuration Protocol (DHCPv4) [<em>not yet implemented</em>]<br>
  <a href="http://www.ietf.org/rfc/rfc3397.txt">RFC 3397</a>: Dynamic Host Configuration 
  Protocol (DHCP) Domain Search Option<br>
  <a href="http://www.ietf.org/rfc/rfc3442.txt">RFC 3442</a>: The Classless Static 
  Route Option for Dynamic Host Configuration Protocol (DHCP) version 4<br>
  <a href="http://www.ietf.org/rfc/rfc3679.txt">RFC 3679</a>: Unused Dynamic Host 
  Configuration Protocol (DHCP) Option Codes<br>
  <a href="http://www.ietf.org/rfc/rfc3942.txt">RFC 3942</a>: Reclassifying Dynamic 
  Host Configuration Protocol version 4 (DHCPv4) Options<br>
  <a href="http://www.ietf.org/rfc/rfc4388.txt">RFC 4388</a>: Dynamic Host Configuration 
  Protocol (DHCP) Leasequery</p>
<h4>Are there some non conformance to RFCs?</h4>
<p>RFC 2131 - section 4.1 - the behaviour of the server can not be totally conformant 
  due to Java limitation.</p>
<pre>
   [...]
   If 'giaddr' is zero and 'ciaddr' is zero, and the broadcast bit is
   set, then the server broadcasts DHCPOFFER and DHCPACK messages to
   0xffffffff. If the broadcast bit is not set and 'giaddr' is zero and
   'ciaddr' is zero, then <u>the server unicasts DHCPOFFER and DHCPACK
</u>   <u>messages to the client's hardware address and 'yiaddr' address</u>.
   [...]</pre>
</p>
It is not possible to unicast UDP datagrams to hardware addresses using the Java 
API. Only unicast to IP addresses are supported. As a side effect, servers act 
always as if the broadcast bit is always set. This has no functional impact on 
clients and negligible impact on network traffic. 
<p><strong>Who uses DHCP4Java?</strong></p>
<p>[Coming soon]</p>
<p></p>
<hr WIDTH="100%" />
<font size="1">Copyright 2006 Stephan Hadinger</font><br>
<font size="1">hosted by </font> <A href="http://sourceforge.net"><IMG src="http://sourceforge.net/sflogo.php?group_id=15278" width="88" height="31"
border="0" alt="SourceForge Logo"></A> 
</body>
</html>
